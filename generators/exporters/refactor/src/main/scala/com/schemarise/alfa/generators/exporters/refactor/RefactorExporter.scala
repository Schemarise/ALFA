package com.schemarise.alfa.generators.exporters.refactor

import com.schemarise.alfa.compiler.ast.model.types.UdtType
import com.schemarise.alfa.compiler.ast.model.types.UdtType.UdtType
import com.schemarise.alfa.compiler.ast.nodes.datatypes.UdtDataType
import com.schemarise.alfa.compiler.ast.nodes.{Field, UdtBaseNode}
import com.schemarise.alfa.compiler.utils.VFS

import java.nio.file.Path
import com.schemarise.alfa.generators.common._

import scala.collection.mutable
import scala.collection.mutable.{HashMap, ListBuffer, MultiMap, Set}

object RefactorExporter {
  val Namespace = "namespace"
  val ExcludeFields = "excludeFields"
  val OnlyIncludeFields = "onlyIncludeFields"
  val AttribSizeThreshold = "groupAttribSizeThreshold"
  val UsageCountPercentage = "groupUsageCountPercentage"
  val GeneratedNamePrefix = "generatedNamePrefix"
  val FullyGeneralize = "fullyGeneralize"
}

class RefactorExporter(param: AlfaExporterParams) extends AlfaExporter(param) with SupportedGenerator {

  private val attribSizeThreshold = Integer.parseInt(param.exportConfig.getOrDefault(RefactorExporter.AttribSizeThreshold, "2").toString)
  private val usageCountPercentage = Integer.parseInt(param.exportConfig.getOrDefault(RefactorExporter.UsageCountPercentage, "90").toString)
  private val excludeFields = param.exportConfig.getOrDefault(RefactorExporter.ExcludeFields, "").toString.split(",").filter( _.length > 0)
  private val onlyIncludeFields = param.exportConfig.getOrDefault(RefactorExporter.OnlyIncludeFields, "").toString.split(",").filter( _.length > 0)
  private val generatedNamePrefix = param.exportConfig.getOrDefault(RefactorExporter.GeneratedNamePrefix, "Base")
  private val namespace = param.exportConfig.get(RefactorExporter.Namespace)
  private val fullyGeneralize = param.exportConfig.getOrDefault(RefactorExporter.FullyGeneralize, "true").toString.toLowerCase.equals("true")

  override def writeTopComment() = false

  override def exportSchema(): List[Path] = {

    val generalized = generalize()

    val cua = param.cua

    VFS.mkdir(param.outputDir)

    cua.getUdtVersionNames().foreach(n => {
      val udt = cua.getUdt(n.fullyQualifiedName).get.asInstanceOf[UdtBaseNode]

      if (!udt.isSynthetic) {
        val gen = generalized.types.get(udt.name.fullyQualifiedName)

        val t = if (gen.isEmpty) {
          udt.toString
        } else {
          udt.toStringWith(() => {
            udt.includes ++ gen.get.includes.map(i => UdtDataType.fromName(i))
          },
            () => {
              val allowedFields = gen.get.attr.keys.toSet
              udt.fields.filter(f => allowedFields.contains(f.field.get.name))
            }
          )
        }

        val tgt = param.outputDir.resolve(n.fullyQualifiedName + ".alfa")
        logger.info(s"Writing $tgt")
        VFS.write(tgt, t)
      }
    })

    val newBaseTypes = generalized.types.values.filter(t => t.fromRefactor)
    newBaseTypes.foreach(t => {
      val fields = t.attr.values.map(f => {
        f.field.toString
      }).mkString("\n")

      val incs = if (t.includes.isEmpty) " " else t.includes.mkString(" includes ", ", ", " ")
      VFS.write(param.outputDir.resolve(t.fqn + ".alfa"),
        s"""// Generated by ALFA Refactor
           |
           |trait ${t.fqn}$incs{
           |${indent("  ", fields)}
           |}
           |""".stripMargin)
    })

    List.empty
  }

  private def generalize() = {
    val cua = param.cua

    val attrs = new mutable.HashMap[String, Attr]()
    val types: Map[String, Type] = cua.getUdtVersionNames().filter(e => isFieldContainer(e.udtType)).map(vn => {
    val udt = cua.getUdt(vn.fullyQualifiedName).get.asInstanceOf[UdtBaseNode]

    val fields = udt.allFields.values.
        filter(f => onlyIncludeFields.isEmpty || onlyIncludeFields.contains(f.name) ).
        filter(f => !excludeFields.contains(f.name)).
        map(f => f.name -> {

          val fk = f.name + "__" + f.dataType.toString

          var a = attrs.get(fk)
          if (!a.isDefined) {
            a = Some(Attr(f.name, f)(new ListBuffer[String]))
            attrs.put(fk, a.get)
          }

          a.get.usedIn.append(vn.fullyQualifiedName)
          a.get
        }).toMap

      val mutableFields = mutable.Map(fields.toSeq: _*)
      val t = Type(udt.name.fullyQualifiedName, mutableFields)(new ListBuffer[String])
      udt.name.fullyQualifiedName -> t
    }).toMap
    val mutableTypes = mutable.Map(types.toSeq: _*)

    val allTypes = Types(mutableTypes)
    _generalize(allTypes, attrs)

    allTypes
  }

  private def _generalize(allTypes: Types, allAttrs: mutable.HashMap[String, Attr]) = {

    val typeBasedOnUse = new HashMap[List[String], Set[Attr]] with MultiMap[List[String], Attr]

    allAttrs.values.map(a => {
      val x = a.usedIn.sorted.toList
      typeBasedOnUse.addBinding(x, a)
    })

    val typeBasedOnUseOrdered =  typeBasedOnUse.toList.sortBy( e => e._2.size )

    val newBaseTypes = new mutable.HashMap[String, scala.collection.mutable.Set[String]]()

    typeBasedOnUseOrdered.
      filter(e => e._1.size > 1).
      filter(e => e._2.size >= attribSizeThreshold || 100 * e._1.size / allTypes.types.size > usageCountPercentage).
      zipWithIndex.
      foreach(c => {
        val types = c._1._1
        val attrs = c._1._2
        val idx = c._2

        val baseTypeName = namespace + "." + generatedNamePrefix + (idx + 1)
        val baseTypeAttrs = attrs.map(a => a.name -> a).toMap
        val mutableBaseTypeAttrs: mutable.Map[String, Attr] = mutable.Map(baseTypeAttrs.toSeq: _*)

        val newBaseType = Type(baseTypeName, mutableBaseTypeAttrs)(new mutable.ListBuffer[String], true)
        allTypes.types.put(baseTypeName, newBaseType)

        val typesSet = new mutable.HashSet[String]()
        typesSet ++= types.toSet

        newBaseTypes.put(baseTypeName, typesSet)
      })


    val sortedNewBaseTypes = newBaseTypes.toList.sortBy( e => e._2.size ).reverse

    if ( fullyGeneralize ) {
      adjustLevels(sortedNewBaseTypes, allTypes)
    }

    sortedNewBaseTypes.foreach(e => {
      val name = e._1
      val becomesBaseTo = e._2

      val baseTypeDef = allTypes.types.get(name).get

      becomesBaseTo.foreach(bt => {
        val userDefType = allTypes.types.get(bt).get
        userDefType.includes.append(name)

        baseTypeDef.attr.keys.foreach(k => {
          userDefType.attr.remove(k)
        })
      })
    })
  }

  private def adjustLevels(newBaseTypes: List[(String, mutable.Set[String])], allTypes: Types): Boolean = {
    var modified = false
    newBaseTypes.filter(outer => !outer._2.isEmpty).foreach(outer => {
      newBaseTypes.filter(inner => !outer._1.equals(inner._1)).foreach(inner => {
        if (!inner._2.isEmpty && inner._2.subsetOf(outer._2) && !inner._2.equals(outer._2)) {

          val innerIncs = allTypes.types.get(inner._1).get.includes

          val cyclic = hasCycle(allTypes, inner._1, innerIncs.toList ++ List(outer._1), List.empty)

          if (! cyclic) {
            innerIncs.append(outer._1)
            inner._2.foreach( t => {
              outer._2.remove(t)
              modified = true
            })
          }
        }
      })
    })

    modified
  }

  private def hasCycle(allTypes: Types, target: String, targetsIncludes : List[String], visiting: List[String]): Boolean = {
    if (visiting.contains(target))
      true
    else {
      val res = targetsIncludes.map(i => hasCycle(allTypes, i, allTypes.types.get(i).get.includes.toList, visiting ++ List(target))).filter(_ == true)
      res.size > 0
    }
  }

  private def isFieldContainer(t: UdtType) =
    t == UdtType.union || t == UdtType.entity || t == UdtType.`trait` || t == UdtType.union || t == UdtType.record || t == UdtType.key


  override def supportedConfig(): Array[String] = requiredConfig() ++
    Seq(RefactorExporter.ExcludeFields, RefactorExporter.OnlyIncludeFields, RefactorExporter.UsageCountPercentage,
      RefactorExporter.AttribSizeThreshold, RefactorExporter.FullyGeneralize)

  override def requiredConfig(): Array[String] = Array(RefactorExporter.Namespace)

  override def name: String = "normalize"

  case class Attr(name: String, field: Field)(val usedIn: mutable.ListBuffer[String]) {
    override def toString: String = {
      name + " : " + field.dataType
    }
  }

  case class Type(fqn: String, attr: mutable.Map[String, Attr])(
    val includes: mutable.ListBuffer[String],
    val fromRefactor: Boolean = false
  ) {
    override def toString: String = {
      val incs = if (includes.isEmpty) "" else includes.mkString(" includes ", ", ", "")
      fqn + incs + " {\n  " +
        attr.values.map(e => e.toString()).mkString("\n  ") +
        "\n}"
    }
  }

  case class Types(types: mutable.Map[String, Type]) {
    override def toString: String = {
      types.values.map(e => e.toString()).mkString("\n")
    }
  }
}
