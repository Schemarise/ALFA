package com.schemarise.alfa.generators.exporters.refactor

import com.schemarise.alfa.compiler.ast.model.types.UdtType
import com.schemarise.alfa.compiler.ast.model.types.UdtType.UdtType
import com.schemarise.alfa.compiler.ast.nodes.datatypes.UdtDataType
import com.schemarise.alfa.compiler.ast.nodes.{Field, UdtBaseNode}
import com.schemarise.alfa.compiler.utils.VFS
import com.schemarise.alfa.generators.common._

import java.nio.file.Path
import scala.collection.mutable
import scala.collection.mutable.{HashMap, ListBuffer, MultiMap, Set}

object RefactorExporterOLD {
  val Namespace = "namespace"
  val IgnoreFields = "ignoreFields"
  val AttribSizeThreshold = "attribSizeThreshold"
  val UsageCountThreshold = "usageCountThreshold"
}

class RefactorExporterOLD(param: AlfaExporterParams) extends AlfaExporter(param) with SupportedGenerator {

  private val attribSizeThreshold = Integer.parseInt(param.exportConfig.getOrDefault("attribSizeThreshold", "2").toString)
  private val usageCountThreshold = Integer.parseInt(param.exportConfig.getOrDefault("usageCountThreshold", "10").toString)
  private val ignoreFields = param.exportConfig.getOrDefault("ignoreFields", "").toString.split(",")
  private val namespace = param.exportConfig.get("namespace")

  override def writeTopComment() = false

  override def exportSchema(): List[Path] = {
    val generalized = generalize()

    val cua = param.cua

    VFS.mkdir(param.outputDir)

    cua.getUdtVersionNames().foreach(n => {
      val udt = cua.getUdt(n.fullyQualifiedName).get.asInstanceOf[UdtBaseNode]

      if (!udt.isSynthetic) {
        val gen = generalized.types.get(udt.name.fullyQualifiedName)

        val t = if (gen.isEmpty) {
          udt.toString
        } else {
          udt.toStringWith(() => {
            udt.includes ++ gen.get.includes.map(i => UdtDataType.fromName(i))
          },
            () => {
              val allowedFields = gen.get.attr.keys.toSet
              udt.fields.filter(f => allowedFields.contains(f.field.get.name))
            }
          )
        }

        VFS.write(param.outputDir.resolve(n.fullyQualifiedName + ".alfa"), t)
      }
    })

    val newBaseTypes = generalized.types.values.filter(t => t.fromRefactor)
    newBaseTypes.foreach(t => {
      val fields = t.attr.values.map(f => {
        f.field.toString
      }).mkString("\n")

      val incs = if (t.includes.isEmpty) " " else t.includes.mkString(" includes ", ", ", " ")
      VFS.write(param.outputDir.resolve(t.fqn + ".alfa"),
        s"""// Generated by ALFA Refactor
           |
           |trait ${t.fqn}$incs{
           |${indent("  ", fields)}
           |}
           |""".stripMargin)
    })

    List.empty
  }

  private def generalize() = {
    val cua = param.cua

    val attrs = new mutable.HashMap[String, Attr]()

    val types: Map[String, Type] = cua.getUdtVersionNames().filter(e => isFieldContainer(e.udtType)).map(vn => {
      val udt = cua.getUdt(vn.fullyQualifiedName).get.asInstanceOf[UdtBaseNode]
      val fields = udt.allFields.values.
        filter(f => !ignoreFields.contains(f.name)).
        map(f => f.name -> {

          val fk = f.name + "__" + f.dataType.toString

          var a = attrs.get(fk)
          if (!a.isDefined) {
            a = Some(Attr(f.name, f)(new ListBuffer[String]))
            attrs.put(fk, a.get)
          }

          a.get.usedIn.append(vn.fullyQualifiedName)
          a.get
        }).toMap

      val mutableFields = mutable.Map(fields.toSeq: _*)
      val t = Type(udt.name.fullyQualifiedName, mutableFields)(new ListBuffer[String])
      udt.name.fullyQualifiedName -> t
    }).toMap

    val mutableTypes = mutable.Map(types.toSeq: _*)

    val allTypes = Types(mutableTypes)

    _generalize(allTypes, attrs)

    allTypes
  }

  private def _generalize(allTypes: Types, allAttrs: mutable.HashMap[String, Attr]) = {

    val typeBasedOnUse = new HashMap[List[String], Set[Attr]] with MultiMap[List[String], Attr]

    allAttrs.values.map(a => {
      val x = a.usedIn.sorted.toList
      typeBasedOnUse.addBinding(x, a)
    })

    val newBaseTypes = new mutable.HashMap[String, scala.collection.mutable.Set[String]]()

    typeBasedOnUse.
      filter(e => e._1.size > 1).
      filter(e => e._2.size >= attribSizeThreshold || e._1.size > usageCountThreshold).
      zipWithIndex.
      foreach(c => {
        val types = c._1._1
        val attrs = c._1._2
        val idx = c._2

        val baseTypeName = param.exportConfig.get("namespace") + ".Base" + (idx + 1)
        val baseTypeAttrs = attrs.map(a => a.name -> a).toMap
        val mutableBaseTypeAttrs: mutable.Map[String, Attr] = mutable.Map(baseTypeAttrs.toSeq: _*)

        val newBaseType = Type(baseTypeName, mutableBaseTypeAttrs)(new mutable.ListBuffer[String], true)
        allTypes.types.put(baseTypeName, newBaseType)

        val typesSet = new mutable.HashSet[String]()
        typesSet ++= types.toSet

        newBaseTypes.put(baseTypeName, typesSet)
      })

    while ( adjustLevels( newBaseTypes, allTypes ) ) { }

    newBaseTypes.foreach(e => {
      val name = e._1
      val becomesBaseTo = e._2

      val baseTypeDef = allTypes.types.get(name).get

      becomesBaseTo.foreach(bt => {
        val userDefType = allTypes.types.get(bt).get
        userDefType.includes.append(name)

        baseTypeDef.attr.keys.foreach(k => {
          userDefType.attr.remove(k)
        })
      })
    })
  }

  private def adjustLevels(newBaseTypes: mutable.HashMap[String, mutable.Set[String]], allTypes : Types) : Boolean = {
    var modified = false
    newBaseTypes.filter(b1 => !b1._2.isEmpty).foreach(b1 => {
      newBaseTypes.filter(b2 => !b1._1.equals(b2._1)).foreach(b2 => {
        if (!b2._2.isEmpty && b2._2.subsetOf(b1._2)) {

          println(">>> b1: " + b1._2 + "\n    b2: " + b2._2)

          allTypes.types.get(b2._1).get.includes.append(b1._1)
          b2._2.foreach(t => {
            b1._2.remove(t)
            modified = true
          })
        }
      })
    })

    modified
  }

  private def isFieldContainer(t: UdtType) =
    t == UdtType.union || t == UdtType.entity || t == UdtType.`trait` || t == UdtType.union || t == UdtType.record || t == UdtType.key


  override def supportedConfig(): Array[String] = requiredConfig() ++
    Seq(RefactorExporter.IgnoreFields, RefactorExporter.UsageCountPercentage, RefactorExporter.AttribSizeThreshold)

  override def requiredConfig(): Array[String] = Array(RefactorExporter.Namespace)

  override def name: String = "normalize"


  case class Attr(name: String, field: Field)(val usedIn: mutable.ListBuffer[String]) {
    override def toString: String = {
      name + " : " + field.dataType
    }
  }

  case class Type(fqn: String, attr: mutable.Map[String, Attr])(
    val includes: mutable.ListBuffer[String],
    val fromRefactor: Boolean = false
  ) {
    override def toString: String = {
      val incs = if (includes.isEmpty) "" else includes.mkString(" includes ", ", ", "")
      fqn + incs + " {\n  " +
        attr.values.map(e => e.toString()).mkString("\n  ") +
        "\n}"
    }
  }

  case class Types(types: mutable.Map[String, Type]) {
    override def toString: String = {
      types.values.map(e => e.toString()).mkString("\n")
    }
  }
}
