package com.schemarise.alfa.generators.common

import com.schemarise.alfa.compiler.ast.nodes._
import com.schemarise.alfa.compiler.ast.nodes.datatypes.UdtDataType
import com.schemarise.alfa.compiler.utils.{ILogger, TextUtils, VFS}
import com.schemarise.alfa.compiler.{CompilationUnitArtifact, Context}

import java.nio.file.Path
import scala.collection.JavaConverters._

object TextWriter {
  def indent(indent: String, contents: String) = {
    indent + contents.replaceAll("\n", s"\n$indent")
  }
}

abstract class TextWriter(val logger: ILogger) {

  val dollar = "$"
  val at = ""; // "@"
  private val files: java.util.Stack[Path] = new java.util.Stack[Path]()
  private val writtenFiles: java.util.Stack[Path] = new java.util.Stack[Path]()
  private val buffers: java.util.Stack[StringBuilder] = new java.util.Stack[StringBuilder]()

  private val memBuffer = new StringBuilder()

  def outputDirectory: Path

  def commentLineStart(): String = "//"

  def commentLineEnd(): String = ""

  def firstLine() = ""

  def outputFiles = writtenFiles.asScala.toList

  def writeTopComment() = true

  def alfaCodeLine(s: Any) = {
    val str = s.toString
    val idx = str.indexOf("\n")

    if (idx > 0)
      str.substring(0, idx) + ".."
    else
      str
  }

  def writeAlfaFiles(ctx: Context, alfaNamespace: String) = {

    val types = ctx.registry.allUserDeclarations

    val udts = types.map(t => ctx.registry.getUdt(None, UdtDataType.fromName(t), false).get).toList


    val nn = new NamespaceNode(collectedUdts = udts, nameNode = StringNode.create(alfaNamespace))
    val cu = new CompilationUnit(ctx = ctx, namespaces = Seq(nn), modelVersion = None)
    val cua = new CompilationUnitArtifact(ctx, cu)

    Field.separator = "\n"

    udts.foreach(u => {
      val tn = u.name.fullyQualifiedName

      enterFile(tn + ".alfa")


      writeln(
        s"""
           |namespace $alfaNamespace
           |
           |${u.toString}
         """.stripMargin)
      exitFile()

      logger.debug("Generated " + tn)
    })

    Field.separator = ""

  }

  def recordLocation(e: Locatable) = {
    val src = if (e.location.getSourcePath.isEmpty) "" else e.location.getSourcePath.get.getFileName.toString
    val line = e.location.getStartLine
    src + "@" + line
  }

  def validLangIdentifier(c: String, langKeywords: Set[String]) = {
    val s1 = if (Character.isJavaIdentifierStart(c.head) && !langKeywords.contains(c))
      c
    else
      '_' + c

    s1.map(c => {
      if (Character.isJavaIdentifierPart(c)) c else "_"
    }).mkString("")
  }

  def enterFile(file: String, topComment: Boolean = true): Path = {
    val p = outputDirectory.resolve(file)

    files.push(p)
    buffers.push(new StringBuilder())

    if (topComment && firstLine().length > 0)
      buffers.peek().append(firstLine())

    if (topComment && writeTopComment()) {
      buffers.peek().append(
        s"""${commentLineStart()} ********************************************************************************************************* ${commentLineEnd()}
           |${commentLineStart()}      DO NOT EDIT. This file has been generated by the Schemarise ALFA toolset. See www.schemarise.com     ${commentLineEnd()}
           |${commentLineStart()} ********************************************************************************************************* ${commentLineEnd()}
           |""".stripMargin)
    }

    p
  }

  def formatSource(p: Path, source: String): String = {
    return source
  }

  def exitFile() =
    if (files.size == 0)
      throw new GeneratorException("No file to exit")
    else {
      val f = files.pop()

      val buf = buffers.pop()
      VFS.write(logger, f, formatSource(f, buf.toString()), true)
      logger.debug("Writing file " + f.toAbsolutePath)
      writtenFiles.push(f)
    }

  def writeln(): Unit = writeln("")

  def writeln(str: String): Unit = {
    write(str + "\n")
  }

  def write(str: String): Unit = {
    if (files.size > 0)
      buffers.peek().append(str)
    else {
      memBuffer.append(str)
      //      print(str)
    }
  }

  def pascalCase(s: String): String =
    TextUtils.pascalCase(s)

  def indent(indent: String, contents: String) = {
    TextWriter.indent(indent, contents)
  }
}
